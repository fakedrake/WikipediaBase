"""
Scrape the attributes out of infoboxes.
"""

import json
import re

from wikipediabase.article import get_article
from wikipediabase.log import Logging
from wikipediabase.renderer import get_renderer
from wikipediabase.util import Expiry, fromstring, totext, tostring

ATTRIBUTE_REGEX = re.compile(r"^\s*\\|\s*([a-zA-Z_\-]+)\s+=")
TEMPLATE_DATA_REGEX = re.compile(r"<templatedata>(.*?)</templatedata>",
                                 flags=re.M | re.S)

# MetaInfobox objects are cached in memory forever
# There are about 3200 infoboxes, so these should easily fit in memory
# Switch to util.LRUCache if memory usage becomes a problem
_META_INFOBOX_CACHE = {}


class MetaInfoboxBuilder(Logging):

    """
    This is an infobox of an infobox. It is an infobox with all the
    valid attributes and each value is all the names of all attributes
    that are equivalent to them. Eg An infobox of type Foo that has
    valid attributes A, B, C and D and A, B and C are equivalent has a
    meta infobox that looks something like:

    | Attribute | Value                   |
    |-----------+-------------------------|
    | A         | !!!A!!! !!!B!!! !!!C!!! |
    | B         | !!!A!!! !!!B!!! !!!C!!! |
    | C         | !!!A!!! !!!B!!! !!!C!!! |
    | D         | !!!D!!!                 |

    A MetaInfobox is generated by looking at both:

    documentation subpages, e.g.
    https://en.wikipedia.org/wiki/Template:Infobox_officeholder/doc

    and documentation pages, e.g.
    https://en.wikipedia.org/wiki/Template:Infobox_officeholder
    """

    def __init__(self, infobox_type):
        prefix = "Template:"
        infobox_type = infobox_type.strip()
        if not infobox_type.startswith(prefix):
            raise ValueError("'%s' is not a valid Infobox template name. "
                             "This function expects infobox_type to have "
                             "format 'Template:Infobox <class>'."
                             % infobox_type)

        self.symbol, self.title = infobox_type, infobox_type.replace(prefix, "")

    def build(self):
        return MetaInfobox(self.symbol, self.title, self.rendered_attributes())

    def attributes(self):
        """
        A list of the markup attributes. Attributes are extracted by looking
        at template documentation subpages and pages.
        """
        # deduplicate and remove empty string
        attributes = self._best_attributes()
        attributes = [self._clean_attribute(a) for a in attributes if a]
        attributes = list(set(attributes))
        return attributes

    def markup_source(self):
        """
        Markup of the meta infobox. Each attribute has a value that
        contains all possible attributes for this type of infobox.
        """

        return '{{' + self.symbol.replace("Template:", "") + "\n" + \
            '\n'.join(["| %s = !!!!!%s!!!!!" % (attr, attr) for
                       attr in self.attributes()]) + \
            "\n}}\n"

    def html_parsed(self):
        """
        Given the infobox html or as soup, return a list of (key, value)
        pairs.
        """

        def escape_lists(val):
            if not val:
                return u""

            return re.sub(
                r"<\s*(/?\s*(br\s*/?|/?ul|/?li))\s*>", "&lt;\\1&gt;", val)

        def unescape_lists(val):
            if not val:
                return u""

            val = re.sub(r"&lt;(/?\s*(br\s*/?|ul|li))&gt;", "<\\1>", val)
            return val

        soup = fromstring(self.html_source())
        # Render all tags except <ul> and <li> and <br>. Escape them
        # in some way and then reparse

        tpairs = []

        for row in soup.findall('.//tr'):
            try:
                e_key, e_val = row.findall('./*')[:2]
            except ValueError:
                continue

            if e_key is not None and e_val is not None:
                # Turn the key into xml string, parse the other tags
                # making brs into newlines, parse the rest of the
                # tags, get the text back
                key = totext(fromstring(tostring(e_key), True))
                key = re.sub(r"\s+", " ", key).strip()
                val = escape_lists(tostring(e_val))
                # Extract text
                val = fromstring(val)
                val = totext(val)
                val = unescape_lists(val.strip())
                tpairs.append((key, val))

        return tpairs

    def html_source(self):
        return get_renderer().render(self.markup_source(), key=self.title)

    def rendered_attributes(self):
        """
        A dictionary mapping unrendered markup attributes to rendered HTML 
        attributes
        """
        attrs = dict()
        for k, v in self.html_parsed():
            for m in re.finditer("!!!!!([^!]+)!!!!!", v):
                attrs[m.group(1)] = k

        return attrs

    def _best_attributes(self):
        """
        Returns the best possible list of attributes from various infobox 
        template pages

        Consider the "president" infobox. We first try to follow any 
        redirects, and find that "president" redirects to "officeholder".

        Then we fetch the wikimarkup source of the template documentation 
        subpage at: "/index.php?title=Template:Infobox_officeholder/doc"

        If it exists, we use the <templatedata> block that contains a JSON
        object with attributes. For more info on <templatedata>, see:
        https://www.mediawiki.org/wiki/Extension:TemplateData. Some templates 
        do not have documentation subpages, just documentation pages (no 
        trailing "/doc").

        We look at the rendered HTML of subpages and pages and use a regex 
        that looks for attributes like "| name    =  BBC News".  

        We fetch markup for infoboxes from live wikipedia.org. We do this to
        follow redirects and have up-to-date rendered attributes. Although this
        is slower than fetching from the backend, we mitigate the performance
        hit by caching all meta infoboxes. The work to build a meta infobox
        should only be done once per infobox template.
        """
        template = self.symbol

        try:
            page = get_article(self.symbol)
            template = page.title
        except LookupError:
            self.log().warn("Could not find doc any template pages for "
                            "template: \"%s\".",
                            self.symbol)
            return []

        attributes = []
        doc_page = get_article(template)
        try:
            doc_subpage = get_article(template + '/doc')

            # fetch markup from live wikipedia.org
            markup = doc_subpage.markup_source(force_live=True,
                                               expiry=Expiry.LONG)
            attributes.extend(self._attributes_from_template_data(markup))

            html = doc_subpage.html_source(expiry=Expiry.LONG)
            attributes.extend(self._attributes_from_html(html))
        except ValueError:
            self.log().error("Error parsing <templatedata> json for %s. "
                             "Check the page for trailing commas. ",
                             template, exc_info=True)
        except LookupError:
            self.log().warn("Could not find doc subpage for template: \"%s\".",
                            template)

        html = doc_page.html_source(expiry=Expiry.LONG)
        attributes.extend(self._attributes_from_html(html))

        return attributes

    def _attributes_from_template_data(self, markup):
        attributes = []
        match = re.search(TEMPLATE_DATA_REGEX, markup)
        if match:
            template_data = json.loads(match.group(1))
            for a in template_data["params"]:
                attributes.append(a)
                if "aliases" in a:
                    attributes.extend(a["aliases"])

        return attributes

    def _attributes_from_html(self, html):
        return re.findall(ATTRIBUTE_REGEX, html)

    def _clean_attribute(self, attr):
        attr = attr.strip()
        while attr[-1].isdigit():
            attr = attr[:-1]
        return attr


class MetaInfobox(Logging):

    def __init__(self, symbol, title, attrs):
        self.symbol = symbol
        self.title = title
        self.attrs = attrs

    def rendered_attributes(self):
        return self.attrs


def get_meta_infobox(symbol):
    """
    Get an infobox that only has keys and not values. A quick and
    dirty way avoid parsing the values of an infobox.
    """
    try:
        ibx = _META_INFOBOX_CACHE[symbol]
        return ibx
    except KeyError:
        ibx = MetaInfoboxBuilder(symbol).build()
        _META_INFOBOX_CACHE[symbol] = ibx
        return ibx
