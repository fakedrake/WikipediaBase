"""
Scrape the attributes out of infoboxes.
"""

import json
import re

from wikipediabase.renderer import WIKIBASE_RENDERER
from wikipediabase.fetcher import StaticFetcher
from wikipediabase.infobox import Infobox
from wikipediabase.util import get_article, Expiry

ATTRIBUTE_REGEX = re.compile(r"^\s*\\|\s*([a-zA-Z_\-]+)\s+=")
TEMPLATE_DATA_REGEX = re.compile(r"<templatedata>(.*?)</templatedata>",
                                 flags=re.M | re.S)


def _clean_attribute(a):
    a = a.strip()
    while a[-1].isdigit():
        a = a[:-1]
    return a


class MetaInfobox(Infobox):

    """
    This is an infobox of an infobox. It is an infobox with all the
    valid attributes and each value is all the names of all attributes
    that are equivalent to them. Eg An infobox of type Foo that has
    valid attributes A, B, C and D and A, B and C are equivalent has a
    meta infobox that looks something like:

    | Attribute | Value                   |
    |-----------+-------------------------|
    | A         | !!!A!!! !!!B!!! !!!C!!! |
    | B         | !!!A!!! !!!B!!! !!!C!!! |
    | C         | !!!A!!! !!!B!!! !!!C!!! |
    | D         | !!!D!!!                 |

    A MetaInfobox is generated by looking at either:

    a documentation subpage, e.g.
    https://en.wikipedia.org/wiki/Template:Infobox_officeholder/doc

    or a documentation page, e.g.
    https://en.wikipedia.org/wiki/Template:Infobox_officeholder
    """

    def __init__(self, infobox_type, fetcher=None, renderer=None, **kw):
        prefix = "Template:"
        infobox_type = infobox_type.strip()
        if not infobox_type.startswith(prefix):
            raise ValueError("'%s' is not a valid Infobox template docpage name"
                             % infobox_type)

        self.symbol, self.title = infobox_type, infobox_type.replace(prefix, "")
        self.renderer = renderer or WIKIBASE_RENDERER

        mu = self.markup_source()
        fetcher = StaticFetcher(self.renderer.render(mu, key=self.title), mu)
        super(MetaInfobox, self).__init__(self.symbol, title=self.title,
                                          fetcher=fetcher, **kw)

    def attributes(self):
        """
        A list of the markup attributes. Attributes are extracted by looking
        at template documentation subpages and pages.

        Consider the "company" MetaInfobox. We first look at the wikimarkup
        source of the template "documentation subpage" at:
        https://en.wikipedia.org/w/index.php?title=Template:Infobox_company/doc

        If it is there, we use the <templatedata> block that contains a json
        object with template attributes. We also use a regex that looks for
        attributes like "| name    =  BBC News".

        For more info on <templatedata>, see:
        https://www.mediawiki.org/wiki/Extension:TemplateData

        Some templates do not have documentation subpages, just documentation
        pages (no trailing "/doc"; "president" is an example). We look at the
        rendered HTML and use the attribute regex because there is no
        <templatedata> block.
        """

        attributes = []

        try:
            doc_page = get_article(self.symbol + '/doc')
            match = re.search(TEMPLATE_DATA_REGEX,
                              doc_page.markup_source(expiry=Expiry.LONG))
            if match:
                template_data = json.loads(match.group(1))
                for a in template_data["params"]:
                    attributes.append(a)
                    if "aliases" in a:
                        attributes.extend(a["aliases"])

        except ValueError:
            self.log().error("Error parsing <templatedata> json for %s. "
                             "Check the page for trailing commas. ",
                             self.symbol, exc_info=True)
        except LookupError:
            self.log().warn("Could not find doc subpage for template: \"%s\". "
                            "Falling back to using the html doc page.",
                            self.symbol)
            # fallback if no /doc page exists
            doc_page = get_article(self.symbol)

        attributes.extend(re.findall(ATTRIBUTE_REGEX,
                                     doc_page.html_source(expiry=Expiry.LONG)))

        # deduplicate and remove empty string
        attributes = [_clean_attribute(a) for a in set(attributes) if a]
        return attributes

    def markup_source(self):
        """
        Markup of the meta infobox. Each attribute has a value that
        contains all possible attributes for this type of infobox.
        """

        return '{{' + self.symbol.replace("Template:", "") + "\n" + \
            '\n'.join(["| %s = !!!!!%s!!!!!" % (attr, attr) for
                       attr in self.attributes()]) + \
            "\n}}\n"

    def html_source(self):
        return self.renderer.render(self.markup_source(), key=self.title)

    def rendered_keys(self):
        """
        A dictionary mapping markup keys to the html they were rendered
        to.
        """

        ret = dict()
        for k, v in self.html_parsed():
            for m in re.finditer("!!!!!([^!]+)!!!!!", v):
                ret[m.group(1)] = k

        return ret
